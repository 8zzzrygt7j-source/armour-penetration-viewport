<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WT Style 3D Penetration – Corrected</title>
<style>
html,body{margin:0;overflow:hidden;background:#000}
#ui{
  position:fixed;top:10px;left:10px;z-index:10;
  font-family:monospace;color:#fff;
  background:rgba(0,0,0,.6);
  padding:10px;border:1px solid rgba(255,255,255,.2)
}
input{width:160px}
button{margin-top:6px}
</style>
</head>
<body>

<div id="ui">
WT STYLE – FULL 3D<br>
Armour thickness: <span id="thv">80</span> mm<br>
<input id="thickness" type="range" min="20" max="200" value="80"><br>
<button onclick="fire()">FIRE</button>
<button onclick="resetArmour()">RESET ARMOUR</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Camera in real 3D angle
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(3.2, 2.2, 3.6);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 2.8);
sun.position.set(6,6,6);
scene.add(sun);

/* ================= ARMOUR ================= */
let armour, armourGeo, armourMat, armourRest;

function buildArmour(){
  if(armour) scene.remove(armour);

  const mm = Number(thickness.value);
  const depth = THREE.MathUtils.clamp(mm / 60, 0.6, 3.2);

  // Armour slab centered at origin, depth on Z
  armourGeo = new THREE.BoxGeometry(
    2.4, 2.0, depth,
    36, 36, 48
  );

  armourMat = new THREE.MeshStandardMaterial({
    color:0x2f4fa8,
    metalness:0.9,
    roughness:0.35,
    transparent:true,
    opacity:0.5
  });

  armour = new THREE.Mesh(armourGeo, armourMat);
  scene.add(armour);

  armourRest = new Float32Array(armourGeo.attributes.position.array);
}

const thickness = document.getElementById("thickness");
const thv = document.getElementById("thv");
thv.textContent = thickness.value;

thickness.oninput = ()=>{
  thv.textContent = thickness.value;
  buildArmour();
};

buildArmour();

function resetArmour(){
  armourGeo.attributes.position.array.set(armourRest);
  armourGeo.attributes.position.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

/* ================= SHELL ================= */
let shell;

function buildShell(){
  const profile = [
    new THREE.Vector2(0.00,0.00),
    new THREE.Vector2(0.02,0.05),
    new THREE.Vector2(0.04,0.20),
    new THREE.Vector2(0.055,0.45),
    new THREE.Vector2(0.055,0.90),
    new THREE.Vector2(0.05,1.00)
  ];

  const geo = new THREE.LatheGeometry(profile, 64);
  geo.rotateX(Math.PI/2);          // align along +Z
  geo.translate(0,0,-0.5);         // nose at front
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color:0xdddddd,
    emissive:0x222222,
    metalness:0.9,
    roughness:0.25
  });

  const m = new THREE.Mesh(geo, mat);
  m.scale.set(1.6,1.6,1.6);
  return m;
}

/* ================= STATE ================= */
let velZ = 0;
let flying = false;
let impacted = false;
let penetrates = false;

/* ================= DEFORMATION ================= */
function deformShell(){
  const pos = shell.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    // deform only nose region
    if(z > -0.05){
      const r = Math.sqrt(x*x + y*y);
      const fall = Math.max(0,1 - r/0.18);

      pos.setZ(i, z - fall*0.28);
      pos.setX(i, x*(1 + fall*1.6));
      pos.setY(i, y*(1 + fall*1.6));
    }
  }

  // smoothing passes
  for(let p=0;p<3;p++){
    for(let i=1;i<pos.count-1;i++){
      pos.setX(i,(pos.getX(i-1)+pos.getX(i)+pos.getX(i+1))/3);
      pos.setY(i,(pos.getY(i-1)+pos.getY(i)+pos.getY(i+1))/3);
    }
  }

  pos.needsUpdate = true;
  shell.geometry.computeVertexNormals();
}

function deformArmourTunnel(entryZ, exitZ){
  const pos = armourGeo.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    const r = Math.sqrt(x*x + y*y);

    // Only deform along shell axis (Z)
    if(r < 0.6 && z > entryZ && z < exitZ){
      const fall = 1 - r/0.6;
      pos.setZ(i, z - fall*0.45);
    }
  }

  pos.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

/* ================= FIRE ================= */
function fire(){
  if(shell) scene.remove(shell);
  shell = buildShell();
  scene.add(shell);

  // start in front of armour
  shell.position.set(0,0,-4);

  velZ = 0.09;
  flying = true;
  impacted = false;

  // simple WT-like penetration threshold
  penetrates = Number(thickness.value) < 120;
}

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  if(flying && shell){
    shell.position.z += velZ;

    // impact at front face
    const frontFaceZ = -armour.geometry.parameters.depth/2;

    if(shell.position.z >= frontFaceZ && !impacted){
      impacted = true;
      deformShell();

      if(penetrates){
        const backFaceZ = armour.geometry.parameters.depth/2;
        deformArmourTunnel(frontFaceZ, backFaceZ);
      } else {
        deformArmourTunnel(frontFaceZ, frontFaceZ + 0.6);
        velZ = 0;
        flying = false;
      }
    }

    // exit if penetrated
    if(penetrates && shell.position.z > armour.geometry.parameters.depth/2 + 1){
      flying = false;
    }
  }

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
