<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WT Style 3D Armour Penetration</title>
<style>
html,body{margin:0;overflow:hidden;background:#000}
#ui{
  position:fixed;top:10px;left:10px;z-index:10;
  font-family:monospace;color:#fff;
  background:rgba(0,0,0,.65);
  padding:10px;border:1px solid rgba(255,255,255,.2)
}
input{width:160px}
button{margin-top:6px}
</style>
</head>
<body>

<div id="ui">
WT STYLE – TRUE 3D<br>
Armour thickness: <span id="thv">80</span> mm<br>
<input id="thickness" type="range" min="20" max="200" value="80"><br>
<button id="fire">FIRE</button>
<button id="reset">RESET ARMOUR</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
/* ======================================================
   SCENE + RENDERER
====================================================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(4, 3, 4);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

/* ======================================================
   LIGHTING
====================================================== */
scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 2.8);
sun.position.set(6,6,6);
scene.add(sun);

/* ======================================================
   ARMOUR
====================================================== */
let armour, armourGeo, armourRest;

function buildArmour(mm){
  if(armour) scene.remove(armour);

  const depth = THREE.MathUtils.clamp(mm/60, 0.6, 3.2);

  armourGeo = new THREE.BoxGeometry(
    2.5, 2.0, depth,
    40, 40, 60
  );

  const mat = new THREE.MeshStandardMaterial({
    color:0x2f4fa8,
    metalness:0.9,
    roughness:0.35,
    transparent:true,
    opacity:0.45
  });

  armour = new THREE.Mesh(armourGeo, mat);
  scene.add(armour);

  armourRest = new Float32Array(armourGeo.attributes.position.array);
}

function resetArmour(){
  armourGeo.attributes.position.array.set(armourRest);
  armourGeo.attributes.position.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

/* ======================================================
   SHELL (FORWARD-FACING, GUARANTEED)
====================================================== */
let shell;

function buildShell(){
  // Lathe profile (nose → base)
  const profile = [
    new THREE.Vector2(0.00,0.00),
    new THREE.Vector2(0.02,0.05),
    new THREE.Vector2(0.04,0.20),
    new THREE.Vector2(0.055,0.45),
    new THREE.Vector2(0.055,0.90),
    new THREE.Vector2(0.05,1.00)
  ];

  const geo = new THREE.LatheGeometry(profile, 64);

  // Orient along +Z (FORWARD)
  geo.rotateX(-Math.PI/2);
  geo.translate(0,0,0.5);
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color:0xdddddd,
    emissive:0x222222,
    metalness:0.9,
    roughness:0.25
  });

  const m = new THREE.Mesh(geo, mat);
  m.scale.set(1.6,1.6,1.6);
  return m;
}

/* ======================================================
   DEFORMATION
====================================================== */
function deformShellExtreme(){
  const pos = shell.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    if(z > 0.0){
      const r = Math.sqrt(x*x + y*y);
      const fall = Math.max(0,1-r/0.18);

      pos.setZ(i, z - fall*0.35);
      pos.setX(i, x*(1 + fall*1.8));
      pos.setY(i, y*(1 + fall*1.8));
    }
  }

  // smooth
  for(let p=0;p<3;p++){
    for(let i=1;i<pos.count-1;i++){
      pos.setX(i,(pos.getX(i-1)+pos.getX(i)+pos.getX(i+1))/3);
      pos.setY(i,(pos.getY(i-1)+pos.getY(i)+pos.getY(i+1))/3);
    }
  }

  pos.needsUpdate = true;
  shell.geometry.computeVertexNormals();
}

function deformArmourTunnel(zStart, zEnd){
  const pos = armourGeo.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    const r = Math.sqrt(x*x + y*y);
    if(r < 0.6 && z > zStart && z < zEnd){
      const fall = 1 - r/0.6;
      pos.setZ(i, z - fall*0.45);
    }
  }

  pos.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

/* ======================================================
   SIMULATION STATE
====================================================== */
let velZ = 0;
let flying = false;
let impacted = false;
let penetrates = false;

/* ======================================================
   FIRE
====================================================== */
function fire(){
  if(shell) scene.remove(shell);

  shell = buildShell();
  scene.add(shell);

  shell.position.set(0,0,-4);
  velZ = 0.1;
  flying = true;
  impacted = false;

  penetrates = Number(thickness.value) < 120;
}

/* ======================================================
   LOOP
====================================================== */
function animate(){
  requestAnimationFrame(animate);

  if(flying && shell){
    shell.position.z += velZ;

    const frontZ = -armour.geometry.parameters.depth/2;
    const backZ  =  armour.geometry.parameters.depth/2;

    if(shell.position.z >= frontZ && !impacted){
      impacted = true;
      deformShellExtreme();

      if(penetrates){
        deformArmourTunnel(frontZ, backZ);
      } else {
        deformArmourTunnel(frontZ, frontZ+0.6);
        velZ = 0;
        flying = false;
      }
    }

    if(penetrates && shell.position.z > backZ + 1){
      flying = false;
    }
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

/* ======================================================
   UI
====================================================== */
const thickness = document.getElementById("thickness");
const thv = document.getElementById("thv");

thv.textContent = thickness.value;
thickness.oninput = ()=>{
  thv.textContent = thickness.value;
  buildArmour(Number(thickness.value));
};

document.getElementById("fire").onclick = fire;
document.getElementById("reset").onclick = resetArmour;

buildArmour(Number(thickness.value));

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
