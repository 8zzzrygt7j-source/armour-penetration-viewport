<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Armour Penetration â€“ Slow Motion</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #ui {
    position:absolute;
    top:10px; left:10px;
    font-family: monospace;
    color:white;
    z-index:10;
  }
</style>
</head>
<body>

<div id="ui">
FULL SLOW MOTION<br>
<button onclick="fire()">FIRE</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0.3, 4);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------- LIGHT ---------- */
scene.add(new THREE.AmbientLight(0x555555));
const key = new THREE.DirectionalLight(0xffffff, 1.8);
key.position.set(5,4,3);
scene.add(key);

/* ---------- ARMOUR TEXTURE ---------- */
const tex = document.createElement("canvas");
tex.width = tex.height = 256;
const ctx = tex.getContext("2d");
ctx.fillStyle = "#3a4d88";
ctx.fillRect(0,0,256,256);
for(let i=0;i<5000;i++){
  const x=Math.random()*256,y=Math.random()*256;
  const v=40+Math.random()*50;
  ctx.fillStyle=`rgb(${v},${v},${v})`;
  ctx.fillRect(x,y,1,1);
}
const armourTex = new THREE.CanvasTexture(tex);

/* ---------- ARMOUR ---------- */
const armourGeo = new THREE.BoxGeometry(0.5, 1.8, 2.8, 8, 16, 8);
const armourMat = new THREE.MeshStandardMaterial({
  map: armourTex,
  metalness: 0.9,
  roughness: 0.3
});
const armour = new THREE.Mesh(armourGeo, armourMat);
scene.add(armour);

/* ---------- SHELL (REAL AP SHAPE) ---------- */
const shellGroup = new THREE.Group();

// body
const bodyGeo = new THREE.CylinderGeometry(0.05,0.05,0.5,16);
const bodyMat = new THREE.MeshStandardMaterial({ color:0x777777 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.rotation.z = Math.PI/2;
shellGroup.add(body);

// tip
const tipGeo = new THREE.ConeGeometry(0.05,0.12,16);
const tipMat = new THREE.MeshStandardMaterial({
  color:0xffaa00,
  emissive:0xff5500
});
const tip = new THREE.Mesh(tipGeo, tipMat);
tip.rotation.z = Math.PI/2;
tip.position.x = 0.31;
shellGroup.add(tip);

scene.add(shellGroup);

let velocity = new THREE.Vector3();
let flying = false;

/* ---------- TRAIL ---------- */
const trailGeo = new THREE.BufferGeometry();
trailGeo.setAttribute("position", new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3));
const trailMat = new THREE.LineBasicMaterial({ color:0xffaa00, linewidth:2 });
const trail = new THREE.Line(trailGeo, trailMat);
scene.add(trail);

/* ---------- FIRE ---------- */
function fire(){
  shellGroup.position.set(-3,0,0);
  shellGroup.scale.set(1,1,1);
  velocity.set(0.08,0,0); // slow motion speed
  flying = true;
}

/* ---------- SPARK BLAST ---------- */
function sparks(pos){
  const geo = new THREE.BufferGeometry();
  const verts=[];
  for(let i=0;i<120;i++){
    verts.push(pos.x,pos.y,pos.z);
  }
  geo.setAttribute("position", new THREE.Float32BufferAttribute(verts,3));
  const mat = new THREE.PointsMaterial({
    color:0xffcc55,
    size:0.07
  });
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);

  let s=0;
  function anim(){
    s+=0.08;
    pts.scale.set(s,s,s);
    mat.opacity -= 0.04;
    mat.transparent=true;
    if(mat.opacity>0) requestAnimationFrame(anim);
    else scene.remove(pts);
  }
  anim();
}

/* ---------- DEFORMATION ---------- */
function deform(point){
  const pos = armour.geometry.attributes.position;
  for(let i=0;i<pos.count;i++){
    const dx = pos.getX(i)-point.x;
    const dy = pos.getY(i)-point.y;
    const dz = pos.getZ(i)-point.z;
    const d = Math.sqrt(dx*dx+dy*dy+dz*dz);
    if(d < 0.45){
      pos.setX(i, pos.getX(i)-0.25*(1-d/0.45));
    }
  }
  pos.needsUpdate = true;
}

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);

  if(flying){
    shellGroup.position.add(velocity);
    shellGroup.rotation.x += 0.15;

    trail.geometry.attributes.position.setXYZ(0,
      shellGroup.position.x,
      shellGroup.position.y,
      shellGroup.position.z
    );
    trail.geometry.attributes.position.setXYZ(1,
      shellGroup.position.x-0.6,
      0,
      0
    );
    trail.geometry.attributes.position.needsUpdate = true;

    if(shellGroup.position.x >= -0.25){
      flying=false;
      deform(shellGroup.position);
      sparks(shellGroup.position);
      shellGroup.scale.set(1.6,0.6,1.6);
    }
  }

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
