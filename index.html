<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Final X-Ray Armour Penetration</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #ui {
    position:absolute;
    top:10px; left:10px;
    font-family: monospace;
    color:white;
    z-index:10;
  }
</style>
</head>
<body>

<div id="ui">
FINAL FORM â€“ X-RAY PENETRATION<br>
<button onclick="fire()">FIRE</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0.25, 4);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0x666666));
const key = new THREE.DirectionalLight(0xffffff, 2.5);
key.position.set(5,4,3);
scene.add(key);

/* ================= ARMOUR ================= */
const armourGeo = new THREE.BoxGeometry(
  0.6, 1.8, 2.8,
  26, 36, 26   // very high density
);

const armourMat = new THREE.MeshStandardMaterial({
  color: 0x3a4d88,
  metalness: 0.9,
  roughness: 0.35,
  transparent: true,
  opacity: 0.55
});

const armour = new THREE.Mesh(armourGeo, armourMat);
scene.add(armour);

/* ================= SHELL BUILDER (ARTILLERY PROFILE) ================= */
let shell;

function buildShell(){
  // Lathe profile: sharp ogive -> cylindrical body -> base
  const profile = [];
  profile.push(new THREE.Vector2(0.00, 0.00));   // nose
  profile.push(new THREE.Vector2(0.02, 0.04));
  profile.push(new THREE.Vector2(0.035,0.10));
  profile.push(new THREE.Vector2(0.045,0.20));
  profile.push(new THREE.Vector2(0.055,0.35));   // full calibre
  profile.push(new THREE.Vector2(0.055,0.75));   // body
  profile.push(new THREE.Vector2(0.050,0.85));   // base taper
  profile.push(new THREE.Vector2(0.045,0.90));   // base

  const geo = new THREE.LatheGeometry(profile, 48);
  geo.rotateZ(Math.PI / 2);
  geo.translate(-0.45, 0, 0);

  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color:0x777777,
    metalness:0.8,
    roughness:0.4
  });

  return new THREE.Mesh(geo, mat);
}

/* ================= STATE ================= */
let velocity = new THREE.Vector3();
let flying = false;
let penetrated = false;
let bend = new THREE.Vector2();

/* ================= FIRE ================= */
function fire(){
  if(shell) scene.remove(shell);

  shell = buildShell();
  scene.add(shell);

  shell.position.set(-3,0,0);
  shell.rotation.set(0,0,0);

  velocity.set(0.06,0,0);
  flying = true;
  penetrated = false;
}

/* ================= ARMOUR TUNNEL ================= */
function deformArmourTunnel(point){
  const pos = armour.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    const dx = x - point.x;
    const r = Math.sqrt(y*y + z*z);

    if(Math.abs(dx) < 0.4 && r < 0.5){
      const fall = 1 - r / 0.5;

      // entry lip
      if(dx < 0){
        pos.setX(i, x - fall * 0.5);
      }
      // interior bore
      else{
        pos.setX(i, x - fall * 0.25);
      }
    }
  }
  pos.needsUpdate = true;
}

/* ================= SHELL DEFORMATION (SMOOTH) ================= */
function deformShellSmooth(){
  const pos = shell.geometry.attributes.position;

  // radial mushroom
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    if(x > 0.18){
      const r = Math.sqrt(y*y + z*z);
      const fall = Math.max(0, 1 - r / 0.12);

      const crush = (0.18 + Math.random()*0.12) * fall;
      const spread = 1 + fall * (0.7 + Math.random()*0.6);

      pos.setX(i, x - crush);
      pos.setY(i, y * spread);
      pos.setZ(i, z * spread);
    }
  }

  // light smoothing pass (kills spikes)
  for(let i=1;i<pos.count-1;i++){
    pos.setY(i, (pos.getY(i)+pos.getY(i-1))*0.5);
    pos.setZ(i, (pos.getZ(i)+pos.getZ(i-1))*0.5);
  }

  pos.needsUpdate = true;
}

/* ================= SHELL CURVATURE ================= */
function bendShell(){
  bend.set(
    (Math.random()-0.5)*0.05,
    (Math.random()-0.5)*0.05
  );

  const pos = shell.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const f = (x + 0.45);

    pos.setY(i, pos.getY(i) - bend.x * f);
    pos.setZ(i, pos.getZ(i) - bend.y * f);
  }

  pos.needsUpdate = true;

  velocity.y += bend.x * 0.6;
  velocity.z += bend.y * 0.6;
}

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  if(flying){
    shell.position.add(velocity);

    shell.rotation.x += velocity.y * 3;
    shell.rotation.z += velocity.z * 3;

    if(shell.position.x >= -0.25 && !penetrated){
      penetrated = true;
      deformArmourTunnel(shell.position);
      deformShellSmooth();
      bendShell();
    }

    if(shell.position.x >= 0.45){
      flying = false;
    }
  }

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
