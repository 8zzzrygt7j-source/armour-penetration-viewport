<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WT Style Armour Test</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #ui{
    position:fixed;top:10px;left:10px;z-index:10;
    font-family:monospace;color:#fff;
    background:rgba(0,0,0,.6);
    padding:10px;border:1px solid rgba(255,255,255,.2)
  }
  button{margin-top:6px}
</style>
</head>
<body>

<div id="ui">
WAR THUNDER STYLE TEST<br>
<button onclick="fire()">FIRE</button><br>
<button onclick="resetArmour()">RESET ARMOUR</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0.6, 0.2, 2.4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0x777777));
const sun = new THREE.DirectionalLight(0xffffff, 2.4);
sun.position.set(5,4,3);
scene.add(sun);

/* ================= ARMOUR ================= */
const armourGeo = new THREE.BoxGeometry(
  0.6, 1.8, 2.8,
  24, 32, 24
);
const armourMat = new THREE.MeshStandardMaterial({
  color:0x3550a0,
  metalness:0.9,
  roughness:0.35,
  transparent:true,
  opacity:0.45
});
const armour = new THREE.Mesh(armourGeo, armourMat);
scene.add(armour);

const armourPos = armour.geometry.attributes.position;
const armourRest = new Float32Array(armourPos.array.length);
armourRest.set(armourPos.array);

function resetArmour(){
  armourPos.array.set(armourRest);
  armourPos.needsUpdate = true;
  armour.geometry.computeVertexNormals();
}

/* ================= SHELL ================= */
let shell;

function buildShell(){
  // Artillery/AP profile
  const profile = [
    new THREE.Vector2(0.00,0.00),
    new THREE.Vector2(0.02,0.05),
    new THREE.Vector2(0.04,0.20),
    new THREE.Vector2(0.055,0.45),
    new THREE.Vector2(0.055,0.85),
    new THREE.Vector2(0.05,0.95)
  ];

  const geo = new THREE.LatheGeometry(profile, 48);
  geo.rotateZ(Math.PI/2);
  geo.translate(-0.45,0,0);
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color:0xdddddd,
    emissive:0x222222,
    metalness:0.9,
    roughness:0.25
  });

  const m = new THREE.Mesh(geo, mat);
  m.scale.set(1.6,1.6,1.6); // visibility guarantee
  return m;
}

/* ================= STATE ================= */
let vel = new THREE.Vector3();
let flying = false;
let impacted = false;

/* ================= FIRE ================= */
function fire(){
  if(shell) scene.remove(shell);

  shell = buildShell();
  scene.add(shell);

  shell.position.set(-3,0,0);
  shell.rotation.set(0,0,0);

  vel.set(0.05,0,0); // SLOW, readable
  flying = true;
  impacted = false;
}

/* ================= ARMOUR TUNNEL ================= */
function deformArmour(point){
  const pos = armour.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    const dx = x - point.x;
    const r = Math.sqrt(y*y+z*z);

    if(Math.abs(dx)<0.45 && r<0.5){
      const f = 1 - r/0.5;
      pos.setX(i, x - f*0.35);
    }
  }

  pos.needsUpdate = true;
  armour.geometry.computeVertexNormals();
}

/* ================= SHELL DEFORMATION ================= */
function deformShell(){
  const pos = shell.geometry.attributes.position;

  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    if(x>0.15){
      const r = Math.sqrt(y*y+z*z);
      const f = Math.max(0,1-r/0.12);
      pos.setX(i, x - f*0.22);
      pos.setY(i, y*(1+f*1.2));
      pos.setZ(i, z*(1+f*1.2));
    }
  }

  // smoothing
  for(let i=1;i<pos.count-1;i++){
    pos.setY(i,(pos.getY(i-1)+pos.getY(i)+pos.getY(i+1))/3);
    pos.setZ(i,(pos.getZ(i-1)+pos.getZ(i)+pos.getZ(i+1))/3);
  }

  pos.needsUpdate = true;
  shell.geometry.computeVertexNormals();
}

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  if(flying && shell){
    shell.position.add(vel);

    if(shell.position.x > -0.35 && !impacted){
      impacted = true;
      deformArmour(shell.position);
      deformShell();
      vel.y = (Math.random()-0.5)*0.02;
      vel.z = (Math.random()-0.5)*0.02;
    }

    if(shell.position.x > 1.8){
      flying = false;
    }
  }

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
