<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WT Style Armour Test â€“ vFinal+</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #ui{
    position:fixed;top:10px;left:10px;z-index:10;
    font-family:monospace;color:#fff;
    background:rgba(0,0,0,.6);
    padding:10px;border:1px solid rgba(255,255,255,.2)
  }
  input{width:160px}
  button{margin-top:6px}
</style>
</head>
<body>

<div id="ui">
WAR THUNDER STYLE TEST<br>
Armour thickness: <span id="thickVal">80</span> mm<br>
<input id="thickness" type="range" min="20" max="200" value="80"><br>
<button onclick="fire()">FIRE</button>
<button onclick="resetArmour()">RESET ARMOUR</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0.8, 0.25, 3.2); // pulled back

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0x777777));
const sun = new THREE.DirectionalLight(0xffffff, 2.5);
sun.position.set(5,4,3);
scene.add(sun);

/* ================= ARMOUR ================= */
let armour, armourGeo, armourMat;
let armourRest;

function buildArmour(){
  if(armour) scene.remove(armour);

  const mm = Number(thickness.value);
  const depth = THREE.MathUtils.clamp(mm/120, 0.4, 1.8);

  armourGeo = new THREE.BoxGeometry(
    depth, 1.8, 2.8,
    24, 32, 24
  );

  armourMat = new THREE.MeshStandardMaterial({
    color:0x3550a0,
    metalness:0.9,
    roughness:0.35,
    transparent:true,
    opacity:0.45
  });

  armour = new THREE.Mesh(armourGeo, armourMat);
  scene.add(armour);

  armourRest = new Float32Array(armourGeo.attributes.position.array);
}

const thickness = document.getElementById("thickness");
const thickVal = document.getElementById("thickVal");
thickVal.textContent = thickness.value;

thickness.oninput = () => {
  thickVal.textContent = thickness.value;
  buildArmour();
};

buildArmour();

function resetArmour(){
  armourGeo.attributes.position.array.set(armourRest);
  armourGeo.attributes.position.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

/* ================= SHAPNEL GROUPS ================= */
const spallGroup = new THREE.Group();
const shellFragGroup = new THREE.Group();
scene.add(spallGroup, shellFragGroup);

function clearFragments(){
  spallGroup.clear();
  shellFragGroup.clear();
}

/* ================= SHELL ================= */
let shell;

function buildShell(){
  const profile = [
    new THREE.Vector2(0.00,0.00),
    new THREE.Vector2(0.02,0.05),
    new THREE.Vector2(0.04,0.20),
    new THREE.Vector2(0.055,0.45),
    new THREE.Vector2(0.055,0.85),
    new THREE.Vector2(0.05,0.95)
  ];

  const geo = new THREE.LatheGeometry(profile, 48);
  geo.rotateZ(Math.PI/2);
  geo.translate(-0.45,0,0);
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color:0xdddddd,
    emissive:0x222222,
    metalness:0.9,
    roughness:0.25
  });

  const m = new THREE.Mesh(geo, mat);
  m.scale.set(1.6,1.6,1.6);
  return m;
}

/* ================= STATE ================= */
let vel = new THREE.Vector3();
let flying = false;
let impacted = false;

/* ================= SHAPNEL ================= */
function spawnFragments(group, pos, color, count, speed){
  for(let i=0;i<count;i++){
    const g = new THREE.BoxGeometry(0.015,0.015,0.015);
    const m = new THREE.MeshStandardMaterial({color});
    const p = new THREE.Mesh(g,m);

    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      speed*(0.5+Math.random()),
      (Math.random()-0.5)*speed,
      (Math.random()-0.5)*speed
    );
    p.userData.life = 40+Math.random()*30;
    group.add(p);
  }
}

/* ================= DEFORMATION ================= */
function deformArmour(point){
  const pos = armourGeo.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    const dx = x-point.x;
    const r = Math.sqrt(y*y+z*z);
    if(Math.abs(dx)<0.4 && r<0.5){
      const f = 1-r/0.5;
      pos.setX(i, x - f*0.35);
    }
  }
  pos.needsUpdate = true;
  armourGeo.computeVertexNormals();
}

function deformShell(){
  const pos = shell.geometry.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    const z = pos.getZ(i);

    if(x>0.15){
      const r = Math.sqrt(y*y+z*z);
      const f = Math.max(0,1-r/0.12);
      pos.setX(i, x - f*0.22);
      pos.setY(i, y*(1+f*1.2));
      pos.setZ(i, z*(1+f*1.2));
    }
  }
  pos.needsUpdate = true;
  shell.geometry.computeVertexNormals();
}

/* ================= FIRE ================= */
function fire(){
  clearFragments();
  if(shell) scene.remove(shell);

  shell = buildShell();
  scene.add(shell);

  shell.position.set(-3,0,0);
  vel.set(0.05,0,0);
  flying = true;
  impacted = false;
}

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  for(const g of [spallGroup, shellFragGroup]){
    g.children.forEach(p=>{
      p.position.add(p.userData.v);
      p.userData.life--;
    });
    g.children = g.children.filter(p=>p.userData.life>0);
  }

  if(flying && shell){
    shell.position.add(vel);

    if(shell.position.x>-0.35 && !impacted){
      impacted = true;
      deformArmour(shell.position);
      deformShell();

      spawnFragments(spallGroup, shell.position, 0xffdd66, 80, 0.04);
      spawnFragments(shellFragGroup, shell.position, 0xaaaaaa, 30, -0.03);

      vel.y = (Math.random()-0.5)*0.03;
      vel.z = (Math.random()-0.5)*0.03;
    }

    if(shell.position.x>2){
      flying=false;
    }
  }

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
